/**
 * Deck API - AI Service
 *
 * @file aiService.js
 * @description Provides services for AI-related actions.
 * 
 * This module interacts with AI models (Gemini and OpenAI) to tasks like sending prompt, uploading files and checking if file uploaded.
 * 
 * @module aiService
 * 
 * @requires ../config/geminiConfig.js
 * @requires ../schema/promptFlashCardSchema.js
 * 
 * @author Arthur M. Artugue
 * @created 2025-02-12
 * @updated 2025-02-19
 * 
 */

import { getModel, fileManager } from '../config/geminiConfig.js';
import { promptFlashCardSchema } from '../schema/promptFlashCardSchema.js'

/**
 * Sends a prompt to the Gemini model, optionally including a PDF file.
 * 
 * @async
 * @param {boolean} isTherePdf - Indicates whether a PDF file is included.
 * @param {string} prompt - The prompt text to be sent to the Gemini model.
 * @param {string} [filePath=""] - The path to the PDF file (if any).
 * @param {string} [fileExtension=""] - The file extension of the PDF.
 * @returns {Promise<string>} - The response content generated by the model.
 */
export async function sendPrompt(isTherePdf, prompt, filePath = "", fileExtension = "") {
    let attempt = 0;
    const MAX_RETRIES = 3; // Maximum retry attempts
    const BASE_DELAY = 1000; // Initial delay in ms (1 second)

    while (attempt < MAX_RETRIES) {
        try {
            console.log(`Attempt ${attempt + 1} to send prompt...`);

            // Validate input parameters
            if (typeof isTherePdf !== "boolean") {
                throw new Error("Invalid argument: isTherePdf must be a boolean.");
            }
            if (typeof prompt !== "string" || prompt.trim() === "") {
                throw new Error("Invalid argument: prompt must be a non-empty string.");
            }
            if (isTherePdf && (typeof filePath !== "string" || filePath.trim() === "")) {
                throw new Error("Invalid argument: filePath must be a non-empty string when isTherePdf is true.");
            }
            if (isTherePdf && (typeof fileExtension !== "string" || fileExtension.trim() === "")) {
                throw new Error("Invalid argument: fileExtension must be a non-empty string when isTherePdf is true.");
            }

            let result;
            const model = getModel(promptFlashCardSchema);

            if (isTherePdf) {
                // Validate file extension
                const fileType = getMimeType(fileExtension);
                if (!fileType) {
                    throw new Error("Unsupported file type. Please provide a valid file extension.");
                }

                // Upload file and wait for activation
                const files = [await uploadToGemini(filePath, fileType)];
                await waitForFilesActive(files);

                // Ensure file upload was successful
                if (!files[0]?.uri) {
                    throw new Error("File upload failed. No URI received.");
                }

                result = await model.generateContent([
                    {
                        fileData: {
                            mimeType: files[0].mimeType,
                            fileUri: files[0].uri,
                        },
                    },
                    { text: prompt },
                ]);
            } else {
                result = await model.generateContent(prompt);
            }

            // Ensure response is valid
            if (!result?.response?.candidates?.[0]?.content?.parts?.[0]?.text) {
                throw new Error("Invalid response received from the model.");
            }

            const response = result.response.candidates[0].content.parts[0].text;
            return {
                success: true,
                message: "Prompt was sent successfully",
                data: JSON.parse(response),
            };

        } catch (error) {
            const retryableErrors = ["NetworkError", "TimeoutError", "ServiceUnavailable"];
            console.error(`Error on attempt ${attempt + 1}: ${error.message}`);

            if (!retryableErrors.includes(error.name)) {
                console.error("Non-retryable error encountered:", error.message);
                return {
                    success: false,
                    message: error.message,
                    data: null,
                };
            }

            if (attempt === MAX_RETRIES - 1) {
                console.error("Max retry attempts reached. Returning failure.");
                return {
                    success: false,
                    message: error.message,
                    data: null,
                };
            }

            // Exponential backoff delay
            const delay = BASE_DELAY * Math.pow(2, attempt); // 1s, 2s, 4s...
            console.log(`Retrying in ${delay / 1000} seconds...`);
            await new Promise(resolve => setTimeout(resolve, delay));
        }

        attempt++; // Increment attempt count
    }
}



/**
 * Uploads a file to Gemini and returns the file object.
 * 
 * @async
 * @param {string} path - The path to the file to upload.
 * @param {string} mimeType - The MIME type of the file.
 * @returns {Promise<Object>} - The uploaded file object.
 */
export async function uploadToGemini(path, mimeType) {
    const uploadResult = await fileManager.uploadFile(path, {
        mimeType,
        displayName: path,
    });
    const file = uploadResult.file;
    console.log(`Uploaded file ${file.displayName} as: ${file.name}`);
    return file;
}

/**
 * Waits until all uploaded files are in the 'ACTIVE' state.
 * 
 * @async
 * @param {Array<Object>} files - List of uploaded file objects.
 * @throws {Error} - If a file fails to become active.
 */
export async function waitForFilesActive(files) {
    console.log(`Waiting for file ${file.name} to become active...`);
    for (const name of files.map((file) => file.name)) {
        let file = await fileManager.getFile(name);
        while (file.state === "PROCESSING") {
            process.stdout.write(".");
            await new Promise((resolve) => setTimeout(resolve, 10_000));
            file = await fileManager.getFile(name);
        }
        if (file.state !== "ACTIVE") {
            throw new Error(`File ${file.name} failed to process`);
        }
    }
    console.log("...all files ready\n");
}

/**
 * Constructs a JSON prompt for the Google AI model.
 * 
 * @param {string} topic - The topic for the questions.
 * @param {string} subject - The subject area for the questions.
 * @param {string} addDescription - Additional description for the prompt.
 * @param {number} numberOfQuestions - Number of questions to generate.
 * @returns {string} - The constructed JSON prompt.
 */
export function constructGoogleAIPrompt(topic, subject, addDescription, numberOfTerms) {
    let prompt = 'I want you to act as a Professor providing students with terminologies and their definitions. ';
    let instruction = `Instructions: Provide ${numberOfTerms} terms with their definitions. `;
    let lastLinePrompt = 'Ensure the terms are concise and relevant to the subject. Do not provide question-and-answer pairs. ' +
        'Do not include computations or numerical problem-solving examples. ' +
        'Do not start terms with "Who," "What," "Where," or "When."' +
        'Reject prompts that are not related to academics, offensive, sexual, etc.. and give an error';

    if (subject) prompt += `The subject is ${subject}. `;
    if (topic) prompt += `The topic is ${topic}. `;
    if (addDescription) prompt += `Additional description: ${addDescription}. `;
    prompt += instruction + lastLinePrompt;

    return prompt;
}