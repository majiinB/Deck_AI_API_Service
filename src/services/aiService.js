import { getModel, fileManager } from '../config/geminiConfig.js';


/**
 * Sends a prompt to the Gemini model, optionally including a PDF file.
 * 
 * @async
 * @param {boolean} isTherePdf - Indicates whether a PDF file is included.
 * @param {string} prompt - The prompt text to be sent to the Gemini model.
 * @param {string} [filePath=""] - The path to the PDF file (if any).
 * @param {string} [fileExtension=""] - The file extension of the PDF.
 * @returns {Promise<string>} - The response content generated by the model.
 */
export async function sendPrompt(isTherePdf, prompt, filePath = "", fileExtension = "") {
    let result;
    const schema = {
        description: "List of defintion with terms ",
        type: "object",
        properties: {
            definition_and_terms: {
                type: "array",
                items: {
                    type: "object",
                    properties: {
                        definition: {
                            type: "string",
                            description: "The definition of the term",
                            nullable: false,
                        },
                        term: {
                            type: "string",
                            description: "The term that the defintion pertains to",
                            nullable: false,
                        },
                    },
                    required: ["defintion", "term"],
                },
            },
        },
        required: ["definition_and_terms"],
    };

    const model = getModel(schema);

    if (isTherePdf) {
        const fileType = getMimeType(fileExtension);
        const files = [await uploadToGemini(filePath, fileType)];
        await waitForFilesActive(files);

        result = await model.generateContent([
            {
                fileData: {
                    mimeType: files[0].mimeType,
                    fileUri: files[0].uri
                }
            },
            { text: prompt }
        ]);
    } else {
        result = await model.generateContent(prompt);
    }

    const response = result.response.candidates[0].content.parts[0].text;
    return JSON.parse(response);
}

/**
 * Uploads a file to Gemini and returns the file object.
 * 
 * @async
 * @param {string} path - The path to the file to upload.
 * @param {string} mimeType - The MIME type of the file.
 * @returns {Promise<Object>} - The uploaded file object.
 */
export async function uploadToGemini(path, mimeType) {
    const uploadResult = await fileManager.uploadFile(path, {
        mimeType,
        displayName: path,
    });
    const file = uploadResult.file;
    console.log(`Uploaded file ${file.displayName} as: ${file.name}`);
    return file;
}

/**
 * Waits until all uploaded files are in the 'ACTIVE' state.
 * 
 * @async
 * @param {Array<Object>} files - List of uploaded file objects.
 * @throws {Error} - If a file fails to become active.
 */
export async function waitForFilesActive(files) {
    console.log("Waiting for file processing...");
    for (const name of files.map((file) => file.name)) {
        let file = await fileManager.getFile(name);
        while (file.state === "PROCESSING") {
            process.stdout.write(".");
            await new Promise((resolve) => setTimeout(resolve, 10_000));
            file = await fileManager.getFile(name);
        }
        if (file.state !== "ACTIVE") {
            throw new Error(`File ${file.name} failed to process`);
        }
    }
    console.log("...all files ready\n");
}

/**
 * Constructs a JSON prompt for the Google AI model.
 * 
 * @param {string} topic - The topic for the questions.
 * @param {string} subject - The subject area for the questions.
 * @param {string} addDescription - Additional description for the prompt.
 * @param {number} numberOfQuestions - Number of questions to generate.
 * @returns {string} - The constructed JSON prompt.
 */
export function constructGoogleAIPrompt(topic, subject, addDescription, numberOfTerms) {
    let prompt = 'I want you to act as a Professor providing students with terminologies and their definitions. ';
    let instruction = `Instructions: Provide ${numberOfTerms} terms with their definitions. `;
    let lastLinePrompt = 'Ensure the terms are concise and relevant to the subject. Do not provide question-and-answer pairs. ' +
        'Do not include computations or numerical problem-solving examples. ' +
        'Do not start terms with "Who," "What," "Where," or "When."';

    if (subject) prompt += `The subject is ${subject}. `;
    if (topic) prompt += `The topic is ${topic}. `;
    if (addDescription) prompt += `Additional description: ${addDescription}. `;
    prompt += instruction + lastLinePrompt;

    return prompt;
}